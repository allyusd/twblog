<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="https://twblog.hongjianching.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://twblog.hongjianching.com/" rel="alternate" type="text/html" /><updated>2018-10-30T22:17:08+08:00</updated><id>https://twblog.hongjianching.com/</id><title type="html">Jian-Ching 記事本</title><subtitle>An notebook website.</subtitle><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><entry><title type="html">2019 iT 邦幫忙鐵人賽 完賽心得</title><link href="https://twblog.hongjianching.com/2018/10/30/2019-ithelp-ironman-30-days-challenge-review/" rel="alternate" type="text/html" title="2019 iT 邦幫忙鐵人賽 完賽心得" /><published>2018-10-30T00:00:00+08:00</published><updated>2018-10-30T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/30/2019-ithelp-ironman-30-days-challenge-review</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/30/2019-ithelp-ironman-30-days-challenge-review/">&lt;p&gt;第 30 天，很高興自己完成這個目標，一開始是想要有個經驗才臨時參賽的，不知道能不能順利完成，幸好有持續的堅持下去。&lt;/p&gt;

&lt;p&gt;一開始覺得 30 天很漫長，因為不知道要寫什麼，雖然有寫過部落格的經驗，加上手邊還有一些草稿筆記，總是會擔心很多狀況。決定 10/01 就開始發文則是因為跟文章數跟日期一樣比較好倒數這個理由，不然先用一個星期累積一定文章再發表的話，壓力應該會比較小一點。&lt;/p&gt;

&lt;h2 id=&quot;每日流程&quot;&gt;每日流程&lt;/h2&gt;

&lt;h3 id=&quot;決定主題&quot;&gt;決定主題&lt;/h3&gt;

&lt;p&gt;每天下班之後，回家要先想今天的主題是什麼，要考慮連貫性、難易性、規模大小，每天都要殺死好多個腦細胞才能決定。&lt;/p&gt;

&lt;h3 id=&quot;進行實驗&quot;&gt;進行實驗&lt;/h3&gt;

&lt;p&gt;決定主題之後開始架設環境、寫程式、做實驗，常常擔心實驗失敗了怎麼辦，會不會來不及，該不該換個主題等等的思緒。&lt;/p&gt;

&lt;h3 id=&quot;撰寫文章&quot;&gt;撰寫文章&lt;/h3&gt;
&lt;p&gt;實驗成功了趕快寫文章，一邊重覆實驗一邊截圖，發現中文需要加強，寫到一半跑去查「不止、不只」的差別，還有「畢竟」怎麼寫。&lt;/p&gt;

&lt;h3 id=&quot;發佈文章&quot;&gt;發佈文章&lt;/h3&gt;
&lt;p&gt;完成文章後很開心，但還要把文章成功發佈出去才算完成，有時候還會卡在這一步，像是當機事件。&lt;/p&gt;

&lt;h2 id=&quot;感想&quot;&gt;感想&lt;/h2&gt;
&lt;p&gt;在參賽前有先看過去年的文章，對於比賽在過了三分之二才正式開始深有同感。一方面是手邊的筆記用掉了，另一方面是實驗的難度提升，不確定性提高了。另外還有一次跟朋友聚餐，回家覺得有點累想睡覺，洗澡時才突然想起來今天還沒有寫文章，如果就跑去睡覺就中斷紀錄了。&lt;/p&gt;

&lt;h3 id=&quot;截稿的壓力&quot;&gt;截稿的壓力&lt;/h3&gt;

&lt;p&gt;整個過程印象中最深的是每天截稿的壓力，雖然字數限制要 300 字不算多，但是要做的事情也不少，常常趕著 12 點前發文。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-30-2019-ithelp-ironman-30-days-challenge-review/2018-10-05_23-41-44.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-30-2019-ithelp-ironman-30-days-challenge-review/2018-10-12_23-48-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-30-2019-ithelp-ironman-30-days-challenge-review/2018-10-26_23-51-33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kpi&quot;&gt;KPI&lt;/h3&gt;
&lt;p&gt;有一天突然發現，明明覺得是做 “同樣” 的事情，但是因為目標(KPI)不同，所以做的方法也跟著不同。以前是單純把一個主題寫完，可以分好幾天寫，也可以簡單幾個程式碼就完成一篇文章；但是這次挑戰有每日限制、字數限制，確實讓我的行為有所改變，像是文章要拆成兩篇不然寫不完，簡單的案例要額外補充資訊不然不到字數限制等等。&lt;/p&gt;

&lt;h3 id=&quot;當機事件&quot;&gt;當機事件&lt;/h3&gt;
&lt;p&gt;因為我沿用寫部落格的習慣，會先上傳到 Github，透過 GitLab CI 產生網頁，然後才把圖片網址貼到 iT 邦幫忙，結果中途遇到 Github 當機事件，還有 GitLab CI 忙錄的情況，都讓我覺得很緊張。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[GitHub資料庫全球大當機24小時，MySQL資料庫異常，波及Issue、合併請求功能失效&lt;/td&gt;
      &lt;td&gt;iThome](https://www.ithome.com.tw/news/126544)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;總結&quot;&gt;總結&lt;/h3&gt;
&lt;p&gt;回顧一開始參賽目標&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;為明年鐵人賽準備&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了這次參賽經驗，相信對明年的挑戰有所幫助&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;清除堆積的筆記並增加部落格文章&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因為後來集中在 Docker 跟 Jenkins 主題，所以只清理了 5 篇文章。部落格文章本來只有 22 篇，這次挑戰增加了 30 篇，足足多了一倍以上。&lt;/p&gt;

&lt;p&gt;對於這次的挑戰覺得最有動力的是留言及訂閱通知以及 LIKE，讓我明白自己寫的文章真的有人在看，如果有幫到別人，花時間整理這些就值得了，謝謝大家。&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><summary type="html">第 30 天，很高興自己完成這個目標，一開始是想要有個經驗才臨時參賽的，不知道能不能順利完成，幸好有持續的堅持下去。</summary></entry><entry><title type="html">溝通，為什麼老闆聽不懂我說的</title><link href="https://twblog.hongjianching.com/2018/10/29/communication-why-the-boss-can't-understand-what-I-said/" rel="alternate" type="text/html" title="溝通，為什麼老闆聽不懂我說的" /><published>2018-10-29T00:00:00+08:00</published><updated>2018-10-29T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/29/communication-why-the-boss-can't-understand-what-I-said</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/29/communication-why-the-boss-can't-understand-what-I-said/">&lt;p&gt;有一天，在路邊&lt;del&gt;發呆&lt;/del&gt;玩寶可夢的時候，聽到這樣的對話&lt;/p&gt;

&lt;p&gt;小明：「跟你說喔，明明跟老闆說用這個方法比較好，但是他總是不同意」&lt;/p&gt;

&lt;p&gt;小華：「會不會老闆不懂你說的方法是什麼」&lt;/p&gt;

&lt;p&gt;小明：「對啊，我也想過這個可能，所以我有跟他說明這個方法如何如何」&lt;/p&gt;

&lt;p&gt;小華：「你說的很清楚很詳細啊，跟著外行老闆真可憐，辛苦你了」&lt;/p&gt;

&lt;p&gt;小明：「就是說啊，本來以為升職之後能夠大展身手的，沒想到反而受制連連，這個不好那個不行的」&lt;/p&gt;

&lt;p&gt;小華：「這樣還不如回到之前單純當個工程師更好」&lt;/p&gt;

&lt;p&gt;小明：「沒錯沒錯，可惜回不去了」&lt;/p&gt;

&lt;p&gt;小華：「那個老闆明明沒能力還不授權，這公司我看前景堪慮啊」&lt;/p&gt;

&lt;p&gt;小明：「唉，別提了，再講下去我都要哭了」&lt;/p&gt;

&lt;p&gt;上述的例子，可能很多人都聽過類似的對話，真實世界中，這些「故事」幾乎天天上演，很多人都想問「為什麼老闆聽不懂我說的呢？」&lt;/p&gt;

&lt;p&gt;這個劇情一再的上演，有些人可能會唉聲嘆氣，怨天尤人或者覺得老闆無所謂我又何必在乎。然後也有些人會自我檢討，開始研究如何訓練口才、製作簡報、提供專業能力，試著改善溝通能力。&lt;/p&gt;

&lt;p&gt;前者就不提了，可惜的是，就算是後者，也常常是屢戰屢敗，熱情漸漸的消磨。這些行動之所以沒有作用，在自己的經驗中，慢慢的領會了其中盲點，&lt;/p&gt;

&lt;p&gt;那就是「無效溝通」&lt;/p&gt;

&lt;p&gt;以實際的例子來說，目前軟體開發顯學 DevOps，當開發者想導入時，往往要向老闆提出建議，主題會放在 DevOps 的解釋，CI / CD 的解釋，Jenkins 工具的運用，帶來的好處及成本。&lt;/p&gt;

&lt;p&gt;如果得到的回覆是「需要更詳細的資訊」，或是「你說的很好，『但是』……」，「再考慮考慮」，雖然表面聽起來有機會，需要進一步努力，但其實代表著「無效溝通」。如果你的老闆夠「真實」的話，他會這麼回答你的「我對這個沒有興趣」，或者更直接的「這樣能夠幫公司賺錢嗎？」&lt;/p&gt;

&lt;p&gt;雖然聽到後面的說法衝擊非常大，但是這是進入真實世界的一記猛擊，也真正的代表之前的都是「無效溝通」，無效溝通之所以會被我覺得可怕的一點，就是很難有自覺。&lt;/p&gt;

&lt;p&gt;「無效溝通」常見的情況就是一昧的陳述自己想說的，而非理解對方的理念或處境。在無自覺的情況下，往往誤以為自己表達的能力不足，所以努力強化展示自己的意圖這個層面。&lt;/p&gt;

&lt;p&gt;「無效溝通」常發現在專業領域及非專業領域的衝突上，專業領域的人會努力的用各種專業術語來表達自己的意圖，但往往收到的成效很低。用一種最簡單的方法比喻，好比兩個說著不同語言的人在溝通，一個說中文一個說英文，當說中文的人發現對方不理解自己意圖時，拼了命了在中文文法上、字詞選擇上作強化，但是卻沒有效果。我想這個比喻大家都能簡單的明白，應該努力的方向很明顯，就是學習英文，只有學習對方的語言，才能進行有效溝通。&lt;/p&gt;

&lt;p&gt;從上面的比喻已經明白，要進行有效溝通，應該要學習「對方的語言」。有沒有想過，老闆的語言是什麼呢？如果你正面臨同樣的處境，身為專業的開發者，是否該跨出舒適圈，往外探索你所不曾踏入的區域呢？&lt;/p&gt;

&lt;h1 id=&quot;延深閱讀&quot;&gt;延深閱讀&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.projectup.net/article/view/id/5424&quot;&gt;向上管理的五個原則 - 專案管理生活思維&lt;/a&gt;&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><summary type="html">有一天，在路邊發呆玩寶可夢的時候，聽到這樣的對話</summary></entry><entry><title type="html">利用程式設計原則解釋職場困境</title><link href="https://twblog.hongjianching.com/2018/10/28/using-principles-of-programming-analysis-real-world/" rel="alternate" type="text/html" title="利用程式設計原則解釋職場困境" /><published>2018-10-28T00:00:00+08:00</published><updated>2018-10-28T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/28/using-principles-of-programming-analysis-real-world</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/28/using-principles-of-programming-analysis-real-world/">&lt;p&gt;正當我在麥當勞吃著嫩煎雞腿堡配著無糖綠邊看漫畫「關於我轉生變成史萊姆這檔事」時，突然耳朵不由自主的補捉到了後方不遠處傳來的一段對話&lt;/p&gt;

&lt;p&gt;小明：「唉~我真搞不懂 PM 在幹嘛，整天只會出張嘴，啥都不管，死都死其它人」&lt;/p&gt;

&lt;p&gt;小華：「總會安排需求跟時程管理吧？」&lt;/p&gt;

&lt;p&gt;小明：「需求就是客戶說的照單全收，問為什麼要這功能不清楚，問使用的情境也說不明白；時程就是說下星期要給，要大家儘量趕；唉，常常連規格書都沒有」&lt;/p&gt;

&lt;p&gt;小華：「疑？那老闆不管的嗎？」&lt;/p&gt;

&lt;p&gt;小明：「老闆只聽他的啊，還幫他說話呢，說都他一個人在承擔客戶的壓力，要多幫忙他」&lt;/p&gt;

&lt;p&gt;小華：「有個狀況外的老闆當他靠山，那我想沒救了」&lt;/p&gt;

&lt;p&gt;小明：「唉，別提了，再講下去我都要哭了」&lt;/p&gt;

&lt;p&gt;聽完對話，感覺就是一個無能的 PM 加上一個可憐的工程師，面對這種情況，我想身為工程師是無能為力的。&lt;del&gt;反正是別人的事&lt;/del&gt;，正當準備將注意力拉回手邊的漫畫時，突然靈光一閃，想到了程式設計原則，下面為了方便說明，給對話中的 PM 起了小王這個名字。&lt;/p&gt;

&lt;p&gt;從對話中分析，小王有六個功能&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;完成專案&lt;/li&gt;
  &lt;li&gt;需求管理&lt;/li&gt;
  &lt;li&gt;時程管理&lt;/li&gt;
  &lt;li&gt;規格書撰寫&lt;/li&gt;
  &lt;li&gt;需求訪談&lt;/li&gt;
  &lt;li&gt;處理客訴&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小明有一個功能&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;實作需求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;畫成 UML 是這個樣子&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-28-using-principles-of-programming-analysis-real-world/2018-10-28_21-15-05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基於單一責任原則，我們可以把面對客戶的部份跟面對專案的部份分開，小王被拆成小王1跟小王2&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-28-using-principles-of-programming-analysis-real-world/2018-10-28_21-15-29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一個人怎麼可能會變成兩個？這明顯不可能。幸好，我們還有接口隔離原則，將功能從人上抽離出來建立角色，小王1是面對專案的部份，角色為專案經理，小王2是面對客戶的部份，角色為業務，小明的角色是工程師&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-28-using-principles-of-programming-analysis-real-world/2018-10-28_21-15-40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好的，就算拆解完 UML 圖，好棒好厲害，那對這件事情有什麼幫助？&lt;/p&gt;

&lt;p&gt;因為上面這張圖是理想中的畫面，回頭看對話，其實會發現小王對於 PM 這個角色的功能實現幾乎沒有&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-28-using-principles-of-programming-analysis-real-world/2018-10-28_21-15-52.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看到這邊，也許你會發現，原來小王根本不是 PM 啊！這是在程式設計中很常發現的壞味道，一個類別做的事情跟名稱不符，這時候就會需要進行最簡單但重要的重構，rename&lt;/p&gt;

&lt;p&gt;不過這還不是我想表達的重點。分析完畢後，我的疑問是，小明真的無能為力嗎？&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><summary type="html">正當我在麥當勞吃著嫩煎雞腿堡配著無糖綠邊看漫畫「關於我轉生變成史萊姆這檔事」時，突然耳朵不由自主的補捉到了後方不遠處傳來的一段對話</summary></entry><entry><title type="html">薛丁格的敏捷教練</title><link href="https://twblog.hongjianching.com/2018/10/27/schrodinger's-agile-coach/" rel="alternate" type="text/html" title="薛丁格的敏捷教練" /><published>2018-10-27T00:00:00+08:00</published><updated>2018-10-27T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/27/schrodinger's-agile-coach</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/27/schrodinger's-agile-coach/">&lt;p&gt;這是參加 &lt;a href=&quot;https://summit.ithome.com.tw/agile/&quot;&gt;Agile Summit 2018&lt;/a&gt; 其中一場，由 Evelyn Tian 演講的&lt;a href=&quot;https://s.itho.me/summit/2018/agile/pdf/Day2-K-03.pdf&quot;&gt;敏捷、蘑菇和西藏之旅&lt;/a&gt;其中的一張圖片&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-27-schrodinger's-agile-coach/2018-10-27_22-31-38.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我將這三條線從上到下理解為「成功的敏捷教練的團隊成效」、「失敗的敏捷教練的團隊成效」、「沒有敏捷教練的團隊成效」&lt;/p&gt;

&lt;p&gt;其中「沒有敏捷教練的團隊成效」是最常聽到「敏捷無用、Scrum 試過無效」最常發生的情況，往往自學自通，甚至是「Scurm 自助餐」，只挑幾個不太需要變革的事情來做，有種柿子挑軟的吃的感覺。結果就是雖然短期似乎有些微改善，但是長期來說沒有變化。&lt;/p&gt;

&lt;p&gt;「失敗的敏捷教練的團隊成效」則是成功的帶領團隊成長，突破，達到了之前不能及的高度。但是，在敏捷教練離開之後，團隊的成果開始下降，雖然短期有所突破，但是卻是長期向下的趨勢。&lt;/p&gt;

&lt;p&gt;最後「成功的敏捷教練的團隊成效」同樣是成功的帶領團隊成長，不同的是當教練離開之後，團隊還能持續的突破，一次一次的邁向新的高峰。&lt;/p&gt;

&lt;p&gt;成功和失敗的團隊，其中很重要的差別在於是否只是單純學到招式，而非心法。真實的環境中一直在改變，如果只是學了招式，雖然短期內成效很好，但是無法應對變化。當明白了每件事背後為什麼要做，就可以自在的變化，面對未來的挑戰&lt;/p&gt;

&lt;p&gt;看圖說故事很簡單，如果要你挑一個教練，當然會想挑上面那個，但是讓我們離開上帝視角，看看下面這張圖&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-27-schrodinger's-agile-coach/2018-10-27_22-31-38-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;當計劃進行中，其實我們是無法分辨兩者的差異，在這個時間點，成功的敏捷教練跟失敗的敏捷教練同時存在，所謂的「薛丁格的敏捷教練」&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><summary type="html">這是參加 Agile Summit 2018 其中一場，由 Evelyn Tian 演講的敏捷、蘑菇和西藏之旅其中的一張圖片</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - Shared Libraries</title><link href="https://twblog.hongjianching.com/2018/10/26/jenkins-pipeline-as-code-shared-libraries/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - Shared Libraries" /><published>2018-10-26T00:00:00+08:00</published><updated>2018-10-26T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/26/jenkins-pipeline-as-code-shared-libraries</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/26/jenkins-pipeline-as-code-shared-libraries/">&lt;p&gt;&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/25/jenkins-pipeline-as-code-dynamic-parallel/&quot;&gt;前一篇&lt;/a&gt;將 Jenkinsfile 內共用的部份重構為一份，那如果是不同的專案之間要共用呢？像這一連串文章，Jenkinsfile 改了無數次，如果有十幾個甚至幾十個專案不就要一直復制貼上，重覆這個動作好幾次？&lt;/p&gt;

&lt;p&gt;我們可以透過 Jenkins Shared Libraries 機制來達到程式碼共用，這邊我們示範單純把整個 Jenkinsfile 封裝起來的方法&lt;/p&gt;

&lt;p&gt;首先將原本的 Jenkinsfile 復制到新的檔案 &lt;strong&gt;vars/commonPipeline.groovy&lt;/strong&gt; 並且用 def call() 包起來，像這樣&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def call() {
    pipeline {
        agent none
        stages {

… 略 …

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接著要把 shared libraries 註冊到 Jenkins，在主頁 &amp;gt; 管理 Jenkins &amp;gt; 設定系統 &amp;gt; Global Pipeline Libraries 新增一組 libary，設定如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Name: pipeline-library&lt;/li&gt;
  &lt;li&gt;Default version: shared-libraries&lt;/li&gt;
  &lt;li&gt;選擇 Modern SCM&lt;/li&gt;
  &lt;li&gt;選擇 Git&lt;/li&gt;
  &lt;li&gt;Project Repository: https://github.com/allyusd/jenkins-pipeline.git&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;填完之後按下儲存，這樣 Jenkins 就知道要去哪裡取得 libary&lt;/p&gt;

&lt;p&gt;接著修改 Jenkinsfile，先載入 libary，再呼叫 commonPipeline&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Library('pipeline-library') _

commonPipeline()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;這麼一來，所有的專案的 Jenkinsfile 就只是轉呼叫 commonPipeline，之後只要修改 commonPipeline，所有的專案都會一起更新的，因為他們使用同一份 libary&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">前一篇將 Jenkinsfile 內共用的部份重構為一份，那如果是不同的專案之間要共用呢？像這一連串文章，Jenkinsfile 改了無數次，如果有十幾個甚至幾十個專案不就要一直復制貼上，重覆這個動作好幾次？</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - 動態平行工作</title><link href="https://twblog.hongjianching.com/2018/10/25/jenkins-pipeline-as-code-dynamic-parallel/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - 動態平行工作" /><published>2018-10-25T00:00:00+08:00</published><updated>2018-10-25T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/25/jenkins-pipeline-as-code-dynamic-parallel</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/25/jenkins-pipeline-as-code-dynamic-parallel/">&lt;p&gt;前一篇介紹&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/24/jenkins-pipeline-as-code-parallel/&quot;&gt;平行工作&lt;/a&gt;，但是每個 stage 其實是一樣的東西，明明重覆的事情要寫好幾遍很討厭，能不能動態產生呢？&lt;/p&gt;

&lt;p&gt;先消除重覆的部份，透過 script 來執成&lt;/p&gt;

&lt;p&gt;宣告兩個變數，分別是存放平行工作的 tasks 及存放 image 列表的 imagelist&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def tasks = [:]
def imagelist = ['maven:3-alpine', 'ubuntu:18.04', 'base/archlinux']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接著透過 for 迴圈將 imagelist 都執行一遍，內容是定義每個 task 要做的事情&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (image in imagelist) {
    def image_inside = &quot;${image}&quot;
    tasks[&quot;${image}&quot;] = {
        node('docker') {
            stage(&quot;${image_inside}&quot;) {
                docker.image(&quot;${image_inside}&quot;).inside {
                    sh &quot;echo ${image_inside}&quot;
                    sh 'cat /etc/*-release'
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面這段程式要特別注意的是其中 &lt;strong&gt;def image_inside = “${image}”&lt;/strong&gt;，這是不能拿掉的喔！另外 &lt;strong&gt;docker.image&lt;/strong&gt; 這段是為了執行在 docker image 內，如果是一般的 agent 是不需要這段的。&lt;/p&gt;

&lt;p&gt;雖然這樣已經達到目的了，但是之後要增加 image 還要需要修改 Jenkinsfile，可能的話當然是希望將可能變動的部份抽離出來。&lt;/p&gt;

&lt;p&gt;要讓 Jenkinfile 不需要修改，可以透過外部檔案來設定 imagelist，所以我們要讀取檔案，並且設定到 imagelist 陣列中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def imagelist = readFile('imagelist').replace(&quot;\n&quot;, &quot;&quot;).split(',')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的指令，先是讀取 imagelist 檔案，移除換行符號之後，依照逗號分隔項目，最後存進 imagelist&lt;/p&gt;

&lt;p&gt;而 imagelist 檔案的內容則是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;maven:3-alpine,ubuntu:18.04,base/archlinux
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整的檔案在 &lt;a href=&quot;https://github.com/allyusd/jenkins-pipeline/tree/agent-docker-dynamic-parallel&quot;&gt;這裡&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;ref&quot;&gt;ref&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://devops.stackexchange.com/questions/3073/how-to-properly-achieve-dynamic-parallel-action-with-a-declarative-pipeline/3090#3090&quot;&gt;jenkins - How to properly achieve dynamic parallel action with a declarative pipeline? - DevOps Stack Exchange&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/42652533/limiting-jenkins-pipeline-to-running-only-on-specific-nodes?rq=1&quot;&gt;Limiting Jenkins pipeline to running only on specific nodes - Stack Overflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.jenkins-ci.org/browse/JENKINS-44086&quot;&gt;[JENKINS-44086] Parallel nodes for scripted pipelines cannot be clicked - Jenkins JIRA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/37594635/why-an-each-loop-in-a-jenkinsfile-stops-at-first-iteration&quot;&gt;jenkins - Why an each loop in a Jenkinsfile stops at first iteration - Stack Overflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/22917491/reading-file-from-workspace-in-jenkins-with-groovy-script&quot;&gt;Reading file from Workspace in Jenkins with Groovy script - Stack Overflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jenkins.io/doc/book/pipeline/docker/&quot;&gt;Using Docker with Pipeline&lt;/a&gt;&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">前一篇介紹平行工作，但是每個 stage 其實是一樣的東西，明明重覆的事情要寫好幾遍很討厭，能不能動態產生呢？</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - 平行工作</title><link href="https://twblog.hongjianching.com/2018/10/24/jenkins-pipeline-as-code-parallel/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - 平行工作" /><published>2018-10-24T00:00:00+08:00</published><updated>2018-10-24T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/24/jenkins-pipeline-as-code-parallel</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/24/jenkins-pipeline-as-code-parallel/">&lt;p&gt;在之前的範例中，我們都是使用連續流程 pipeline，當某一個 stage 失敗，則剩餘的 stage 直接跳過不再執行，以流水線來說這是正確的。&lt;/p&gt;

&lt;p&gt;一般流水線的基本 stage 是 build, test, deploy，當 build 失敗的時候，意味著下一個 test stage 勢必沒有辦法執行，所以直接跳過這個 stage。而 test 失敗的時候，表示沒有通過測試，不應該進行 deploy。&lt;/p&gt;

&lt;p&gt;但是，有個情況是，假如我是一個網頁程式，想要測試時跑在 chrome, firefox, ie 等環境，這時三者之間獨立存在，彼此沒有關聯。假如在 chrome 失敗了，並不代表在 firefox 及 ie 會失敗，所以不應該直接跳過，這時三個 stage 就應該是平行工作。&lt;/p&gt;

&lt;p&gt;接下來的測試借用前一篇&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/23/jenkins-pipeline-as-code-run-docker-image/&quot;&gt;Jenkins - Pipeline as Code - 啟動 Docker Image&lt;/a&gt;的範例來示範，原先執行了三個 docker image，我們現在故意讓第一個失敗，把 image 改為不存在的 &lt;strong&gt;non-exist:fail&lt;/strong&gt; 看看結果&lt;/p&gt;

&lt;p&gt;(已建立的檔案在 &lt;strong&gt;https://github.com/allyusd/jenkins-pipeline.git&lt;/strong&gt;，故意失敗的 branch 為 &lt;strong&gt;agent-docker-fail&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;從 Stage View 來看，只知道三個 stage 都是 failed 的結果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-41-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;實際到 Logs 確認後，可以發現第一個 stage 失敗之後，後續兩個 stage 直接跳過了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-39-29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;為了達到平行工作的目的，我們可以使用 &lt;strong&gt;parallel&lt;/strong&gt; 關鍵字，透過平行宣告，讓這三個 stage 不再有上下流的關係。&lt;/p&gt;

&lt;p&gt;原本的 Jenkinsfile 修改後如下&lt;/p&gt;

&lt;p&gt;(branch 為 &lt;strong&gt;agent-docker-parallel&lt;/strong&gt;)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pipeline {
    agent none
    stages {
        stage('parallel') {
            parallel {
                stage('alpine') {
                    agent {
                        docker {
                            label 'docker'
                            image 'maven:3-alpine'
                        }
                    }
                    steps {
                        sh 'cat /etc/*-release'
                    }
                }
                stage('ubuntu') {
                    agent {
                        docker {
                            label 'docker'
                            image 'ubuntu:18.04'
                        }
                    }
                    steps {
                        sh 'cat /etc/*-release'
                    }
                }
                stage('archlinux') {
                    agent {
                        docker {
                            label 'docker'
                            image 'base/archlinux'
                        }
                    }
                    steps {
                        sh 'cat /etc/*-release'
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;成功執行的情況跟原本的沒太大差別，只是多了一個 parallel stage，事實上沒有做什麼事情。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-47-42.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著把平行版本給弄壞，同樣讓第一個 stage 改成不存在的 image&lt;/p&gt;

&lt;p&gt;(branch 為 &lt;strong&gt;agent-docker-parallel-fail&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;執行後的 Stage View 明顯看出只有第一個 stage 是 failed，其它兩個 stage 都有順利執行，如果是在程式除錯的情況下，就會往第一個環境與其它不同的部份去 debug，為開發人員提供很好的判斷資訊&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-51-23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;改成平行工作，除了讓 stage 消除上下流關係，提供開發人員除錯資訊外，因為彼此獨立，所以如果在有多個可使用 agent 的情況下，是真的可以平行進行的喔。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-56-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上圖表示同樣是 #6，但是一個在執行的時候，還有兩個在佇列中等候，如果幫 Jenkins 再安裝兩個 agent，就可以看到同時進行喔！&lt;/p&gt;

&lt;p&gt;等等，突然想到目前的執行環境是使用 docker image，環境互不影響，那我只要將 ubuntu-18.04 agent &lt;strong&gt;執行程式數量&lt;/strong&gt; 設定為 3 就可以展示效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-59-36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">在之前的範例中，我們都是使用連續流程 pipeline，當某一個 stage 失敗，則剩餘的 stage 直接跳過不再執行，以流水線來說這是正確的。</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - 啟動 Docker Image</title><link href="https://twblog.hongjianching.com/2018/10/23/jenkins-pipeline-as-code-run-docker-image/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - 啟動 Docker Image" /><published>2018-10-23T00:00:00+08:00</published><updated>2018-10-23T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/23/jenkins-pipeline-as-code-run-docker-image</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/23/jenkins-pipeline-as-code-run-docker-image/">&lt;p&gt;這篇要介紹透過 Jenkinsfile 直接啟動 Docker Image 來執行&lt;/p&gt;

&lt;p&gt;早前介紹過&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/10/install-jenkins-agent-with-docker/&quot;&gt;使用 Docker 安裝 Jenkins Agent&lt;/a&gt;，但是這個方法，每個環境都要建立一次該環境的 agent docker image，其實有點麻煩，難道不能讓我直接拿 docker image 來執行呢？&lt;/p&gt;

&lt;p&gt;答案是可以的，所以前一篇介紹&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/22/install-jenkins-agent-on-ubuntu/&quot;&gt;在 Ubuntu 安裝 Jenkins Agent&lt;/a&gt;，目的是使用該 ubuntu 上的 docker 執行環境。如果還沒有安裝 docker 的話，請參考這篇完成&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/02/install-docker/&quot;&gt;安裝 Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先將 ubuntu agent 加上 &lt;strong&gt;docker&lt;/strong&gt; 標籤，避免跑到其它沒有 docker 環境的 agent 上，那就會不能執行了喔&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-21-51.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著修改 Jenkinsfile 關於 agent 的宣告，原本是限制執行在有 &lt;strong&gt;cpp&lt;/strong&gt; 標籤上的像這樣&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;agent {
    label 'cpp'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;改為限制執行在 &lt;strong&gt;docker&lt;/strong&gt; 標籤上，而且要啟動 docker image &lt;strong&gt;maven:3-alpine&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;agent {
    docker {
        label 'docker'
        image 'maven:3-alpine'
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;為了展示在不同 docker image 上執行的能力，我們顯示執行環境的版本資訊&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;steps {
    sh 'cat /etc/*-release'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了 alpine 之外，我們額外新增 ubuntu 及 archlinux 來示範&lt;/p&gt;

&lt;p&gt;完整的 Jenkinsfile 如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pipeline {
    agent none
    stages {
        stage('alpine') {
            agent {
                docker {
                    label 'docker'
                    image 'maven:3-alpine'
                }
            }
            steps {
                sh 'cat /etc/*-release'
            }
        }
        stage('ubuntu') {
            agent {
                docker {
                    label 'docker'
                    image 'ubuntu:18.04'
                }
            }
            steps {
                sh 'cat /etc/*-release'
            }
        }
        stage('archlinux') {
            agent {
                docker {
                    label 'docker'
                    image 'base/archlinux'
                }
            }
            steps {
                sh 'cat /etc/*-release'
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要使用預建立的檔案，同樣在 &lt;strong&gt;https://github.com/allyusd/jenkins-pipeline.git&lt;/strong&gt;，branch 是 &lt;strong&gt;different-agent-docker&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;成功建置之後會出現三個 stage&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-31-20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;alpine 執行結果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-32-40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ubuntu 執行結果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-33-15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;archlinux 執行結果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-34-24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;透過 docker image 啟動不同環境是不是很有彈性呢？&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><category term="Docker" /><summary type="html">這篇要介紹透過 Jenkinsfile 直接啟動 Docker Image 來執行</summary></entry><entry><title type="html">在 Ubuntu 安裝 Jenkins Agent</title><link href="https://twblog.hongjianching.com/2018/10/22/install-jenkins-agent-on-ubuntu/" rel="alternate" type="text/html" title="在 Ubuntu 安裝 Jenkins Agent" /><published>2018-10-22T00:00:00+08:00</published><updated>2018-10-22T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/22/install-jenkins-agent-on-ubuntu</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/22/install-jenkins-agent-on-ubuntu/">&lt;p&gt;之前介紹過&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/10/install-jenkins-agent-with-docker/&quot;&gt;使用 Docker 安裝 Jenkins Agent&lt;/a&gt;，這次要講不使用 Docker 直接在 Ubuntu 安裝 Agent 的方法&lt;/p&gt;

&lt;p&gt;在 Jenkins 主頁，選擇&lt;strong&gt;管理 Jenkins&lt;/strong&gt; &amp;gt; &lt;strong&gt;管理節點&lt;/strong&gt; &amp;gt; &lt;strong&gt;新增節點&lt;/strong&gt; &amp;gt;
&lt;strong&gt;節點名稱&lt;/strong&gt;輸入 &lt;strong&gt;ubuntu-18.04&lt;/strong&gt;，按下 OK&lt;/p&gt;

&lt;p&gt;接著在設定頁輸入&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;遠端檔案系統根目錄：&lt;strong&gt;/data/jenkins&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;啟動模式：&lt;strong&gt;透過 SSH 啟動 Unitx 主機上的 agnet代理程式&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;主機：輸入 IP&lt;/li&gt;
  &lt;li&gt;Credentials：輸入登入主機的 SSH 帳號及密碼&lt;/li&gt;
  &lt;li&gt;Host Key Verification Strategy：圖方便跳過驗證，選擇&lt;strong&gt;Non verifying Verification Strategy&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-43-37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按下儲存之後可以看到 Agent 啟動 Logs，進去看一下發現失敗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-40-20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;訊息上看到提示安裝 java 8，我們透過 ssh 登入 Ubuntu 18.04，確認是不是沒有安裝 java&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-02-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;確實沒有安裝後，接著透過 apt 安裝 java 套件&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo apt install openjdk-8-jre -y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-36-56.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回到 Jenkins Web 再啟動一次，結果又有錯誤發生&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-52-49.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;檢查紀錄原來是 &lt;strong&gt;/data/jenkins&lt;/strong&gt; 目錄不存在，這個好處理。建立一下目鍵，別忘了設定權限&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mkdir -p /data/jenkins
sudo chown ubuntu:ubuntu /data -R
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;回到頁面再次啟動 Agent&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-56-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;終於成功完成 Jenkins Agent 連線&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><category term="Ubuntu" /><summary type="html">之前介紹過使用 Docker 安裝 Jenkins Agent，這次要講不使用 Docker 直接在 Ubuntu 安裝 Agent 的方法</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - Slack Notifier</title><link href="https://twblog.hongjianching.com/2018/10/21/jenkins-pipeline-as-code-slack-notifier/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - Slack Notifier" /><published>2018-10-21T00:00:00+08:00</published><updated>2018-10-21T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/21/jenkins-pipeline-as-code-slack-notifier</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/21/jenkins-pipeline-as-code-slack-notifier/">&lt;p&gt;希望在 Pipeline 異常的時候通知你？透過 Slack Notifier 完成目的&lt;/p&gt;

&lt;h1 id=&quot;jenkins-slack-integration&quot;&gt;Jenkins Slack Integration&lt;/h1&gt;

&lt;p&gt;首先要到 slack 的 apps 管理頁面，&lt;code class=&quot;highlighter-rouge&quot;&gt;https://xxx.slack.com/apps/manage&lt;/code&gt;，其中 xxx 請代入自己的組織名稱，接著在上方搜尋的地方輸入 &lt;code class=&quot;highlighter-rouge&quot;&gt;jenkins&lt;/code&gt; 會出現 &lt;code class=&quot;highlighter-rouge&quot;&gt;Jenkins CI&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_21-46-24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;點選進入 Jenkins CI Apps 頁面，左方有個 &lt;code class=&quot;highlighter-rouge&quot;&gt;Install&lt;/code&gt; 按下去&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_21-46-46.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著會問你想要發訊息到哪一個 Channel，其實隨便選都可以，之後可以在 Jenkins 修改，這邊我選了 &lt;code class=&quot;highlighter-rouge&quot;&gt;#general&lt;/code&gt; 頻道&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_21-47-30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按下之後會有完整的圖文教學，首先要到 Jenkins 管理頁面安裝 &lt;strong&gt;Slack Notification Plugin&lt;/strong&gt;，我使用的 Jenkins 版本跟教學的圖片不一樣，會省略 Plugin 文字，所以要搜尋的話最好只用前面的 &lt;strong&gt;Slack Notification&lt;/strong&gt; 會比較好找到。&lt;/p&gt;

&lt;p&gt;安裝完外掛之後，要到&lt;strong&gt;管理 Jenkins&lt;/strong&gt;，&lt;strong&gt;設定系統&lt;/strong&gt;的&lt;strong&gt;Global Slack Notifier Settings&lt;/strong&gt; 貼上從 Jenkins CI App 教學頁面給的設定&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;設定 Base URL 為https://xxx.slack.com/services/hooks/jenkins-ci/&lt;/li&gt;
  &lt;li&gt;設定 Integration Token 為 Mursq71aDfDJke4cvUWx9n2f&lt;/li&gt;
  &lt;li&gt;設定 Channel 為 general&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;設定後可以按一下 &lt;strong&gt;Test Connection&lt;/strong&gt;，成功時 Slack 會出現測試訊息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_22-46-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jenkinsfile&quot;&gt;Jenkinsfile&lt;/h1&gt;

&lt;p&gt;因為訊息的發佈應該是跨越 stage 的，所以我們在 stages 平行新增一個 post 宣告。當 pipeline 失敗的時候，使用 &lt;strong&gt;failure&lt;/strong&gt; 宣告發送失敗的訊息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;color&lt;/strong&gt; 可以定義發佈訊息旁的顏色標示，失敗時用紅色
&lt;strong&gt;message&lt;/strong&gt; 就是發佈的訊息內容，為了提醒所有人注意到東西壞掉了，可以加上 @channel，太吵的話可以拿掉，或是討論一下為什麼常常壞掉。還可以透過 Jenkins 的變數提供有用的訊息，像是 &lt;strong&gt;env.JOB_BASE_NAME&lt;/strong&gt; 可以提供專案名稱，&lt;strong&gt;env.BUILD_URL&lt;/strong&gt; 則是提供本次建置的網址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;failure {
    slackSend color: '#FF0000',
    message: &quot;@channel ${env.JOB_BASE_NAME} failure. (${env.BUILD_URL})&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了壞掉的時候發出訊息通知外，我們也可以發送一些好消息，像是 &lt;strong&gt;fixed&lt;/strong&gt; 代表東西修好了，也就是原先建置失敗的專案，第一次建置成功的時候發出通知。這次的顏色用綠色，訊息則簡單的說明哪個專案回到建置成功的狀態&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fixed {
    slackSend color: '#00FF00',
    message: &quot;@channel ${env.JOB_BASE_NAME} back to success.&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因為完整的 Jenkinsfile 很長，這次不貼到文章上，直接給&lt;a href=&quot;https://github.com/allyusd/jenkins-pipeline/blob/slack-notifier/Jenkinsfile&quot;&gt;連結&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因為成功的建置不會發送訊息，所以我們先故意用一個壞掉的來建置&lt;/p&gt;

&lt;p&gt;同樣是 &lt;strong&gt;https://github.com/allyusd/jenkins-pipeline.git&lt;/strong&gt;，branch 是 &lt;strong&gt;slack-notifier-fail&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建置失敗，slack 收到了失敗通知&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_22-52-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著換成正確的 branch &lt;strong&gt;slack-notifier&lt;/strong&gt; 然後再建置一次&lt;/p&gt;

&lt;p&gt;這次建置成功，因為前一個建置失敗，所以 slack 收到修復通知&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_22-57-32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ref&quot;&gt;ref&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://jenkins.io/doc/pipeline/steps/slack/#slack-notification-plugin&quot;&gt;Slack Notification Plugin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jenkins.io/doc/pipeline/tour/post/&quot;&gt;Cleaning up and notifications&lt;/a&gt;&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">希望在 Pipeline 異常的時候通知你？透過 Slack Notifier 完成目的</summary></entry></feed>