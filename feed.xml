<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="https://twblog.hongjianching.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://twblog.hongjianching.com/" rel="alternate" type="text/html" /><updated>2018-10-27T22:51:48+08:00</updated><id>https://twblog.hongjianching.com/</id><title type="html">Jian-Ching 記事本</title><subtitle>An notebook website.</subtitle><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><entry><title type="html">薛丁格的敏捷教練</title><link href="https://twblog.hongjianching.com/2018/10/27/schrodinger's-agile-coach/" rel="alternate" type="text/html" title="薛丁格的敏捷教練" /><published>2018-10-27T00:00:00+08:00</published><updated>2018-10-27T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/27/schrodinger's-agile-coach</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/27/schrodinger's-agile-coach/">&lt;p&gt;這是參加 &lt;a href=&quot;https://summit.ithome.com.tw/agile/&quot;&gt;Agile Summit 2018&lt;/a&gt; 其中一場，由 Evelyn Tian 演講的&lt;a href=&quot;https://s.itho.me/summit/2018/agile/pdf/Day2-K-03.pdf&quot;&gt;敏捷、蘑菇和西藏之旅&lt;/a&gt;其中的一張圖片&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-27-schrodinger's-agile-coach/2018-10-27_22-31-38.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我將這三條線從上到下理解為「成功的敏捷教練的團隊成效」、「失敗的敏捷教練的團隊成效」、「沒有敏捷教練的團隊成效」&lt;/p&gt;

&lt;p&gt;其中「沒有敏捷教練的團隊成效」是最常聽到「敏捷無用、Scrum 試過無效」最常發生的情況，往往自學自通，甚至是「Scurm 自助餐」，只挑幾個不太需要變革的事情來做，有種柿子挑軟的吃的感覺。結果就是雖然短期似乎有些微改善，但是長期來說沒有變化。&lt;/p&gt;

&lt;p&gt;「失敗的敏捷教練的團隊成效」則是成功的帶領團隊成長，突破，達到了之前不能及的高度。但是，在敏捷教練離開之後，團隊的成果開始下降，雖然短期有所突破，但是卻是長期向下的趨勢。&lt;/p&gt;

&lt;p&gt;最後「成功的敏捷教練的團隊成效」同樣是成功的帶領團隊成長，不同的是當教練離開之後，團隊還能持續的突破，一次一次的邁向新的高峰。&lt;/p&gt;

&lt;p&gt;成功和失敗的團隊，其中很重要的差別在於是否只是單純學到招式，而非心法。真實的環境中一直在改變，如果只是學了招式，雖然短期內成效很好，但是無法應對變化。當明白了每件事背後為什麼要做，就可以自在的變化，面對未來的挑戰&lt;/p&gt;

&lt;p&gt;看圖說故事很簡單，如果要你挑一個教練，當然會想挑上面那個，但是讓我們離開上帝視角，看看下面這張圖&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-27-schrodinger's-agile-coach/2018-10-27_22-31-38-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;當計劃進行中，其實我們是無法分辨兩者的差異，在這個時間點，成功的敏捷教練跟失敗的敏捷教練同時存在，所謂的「薛丁格的敏捷教練」&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><summary type="html">這是參加 Agile Summit 2018 其中一場，由 Evelyn Tian 演講的敏捷、蘑菇和西藏之旅其中的一張圖片</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - Shared Libraries</title><link href="https://twblog.hongjianching.com/2018/10/26/jenkins-pipeline-as-code-shared-libraries/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - Shared Libraries" /><published>2018-10-26T00:00:00+08:00</published><updated>2018-10-26T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/26/jenkins-pipeline-as-code-shared-libraries</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/26/jenkins-pipeline-as-code-shared-libraries/">&lt;p&gt;&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/25/jenkins-pipeline-as-code-dynamic-parallel/&quot;&gt;前一篇&lt;/a&gt;將 Jenkinsfile 內共用的部份重構為一份，那如果是不同的專案之間要共用呢？像這一連串文章，Jenkinsfile 改了無數次，如果有十幾個甚至幾十個專案不就要一直復制貼上，重覆這個動作好幾次？&lt;/p&gt;

&lt;p&gt;我們可以透過 Jenkins Shared Libraries 機制來達到程式碼共用，這邊我們示範單純把整個 Jenkinsfile 封裝起來的方法&lt;/p&gt;

&lt;p&gt;首先將原本的 Jenkinsfile 復制到新的檔案 &lt;strong&gt;vars/commonPipeline.groovy&lt;/strong&gt; 並且用 def call() 包起來，像這樣&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def call() {
    pipeline {
        agent none
        stages {

… 略 …

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接著要把 shared libraries 註冊到 Jenkins，在主頁 &amp;gt; 管理 Jenkins &amp;gt; 設定系統 &amp;gt; Global Pipeline Libraries 新增一組 libary，設定如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Name: pipeline-library&lt;/li&gt;
  &lt;li&gt;Default version: shared-libraries&lt;/li&gt;
  &lt;li&gt;選擇 Modern SCM&lt;/li&gt;
  &lt;li&gt;選擇 Git&lt;/li&gt;
  &lt;li&gt;Project Repository: https://github.com/allyusd/jenkins-pipeline.git&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;填完之後按下儲存，這樣 Jenkins 就知道要去哪裡取得 libary&lt;/p&gt;

&lt;p&gt;接著修改 Jenkinsfile，先載入 libary，再呼叫 commonPipeline&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Library('pipeline-library') _

commonPipeline()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;這麼一來，所有的專案的 Jenkinsfile 就只是轉呼叫 commonPipeline，之後只要修改 commonPipeline，所有的專案都會一起更新的，因為他們使用同一份 libary&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">前一篇將 Jenkinsfile 內共用的部份重構為一份，那如果是不同的專案之間要共用呢？像這一連串文章，Jenkinsfile 改了無數次，如果有十幾個甚至幾十個專案不就要一直復制貼上，重覆這個動作好幾次？</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - 動態平行工作</title><link href="https://twblog.hongjianching.com/2018/10/25/jenkins-pipeline-as-code-dynamic-parallel/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - 動態平行工作" /><published>2018-10-25T00:00:00+08:00</published><updated>2018-10-25T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/25/jenkins-pipeline-as-code-dynamic-parallel</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/25/jenkins-pipeline-as-code-dynamic-parallel/">&lt;p&gt;前一篇介紹&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/24/jenkins-pipeline-as-code-parallel/&quot;&gt;平行工作&lt;/a&gt;，但是每個 stage 其實是一樣的東西，明明重覆的事情要寫好幾遍很討厭，能不能動態產生呢？&lt;/p&gt;

&lt;p&gt;先消除重覆的部份，透過 script 來執成&lt;/p&gt;

&lt;p&gt;宣告兩個變數，分別是存放平行工作的 tasks 及存放 image 列表的 imagelist&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def tasks = [:]
def imagelist = ['maven:3-alpine', 'ubuntu:18.04', 'base/archlinux']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接著透過 for 迴圈將 imagelist 都執行一遍，內容是定義每個 task 要做的事情&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (image in imagelist) {
    def image_inside = &quot;${image}&quot;
    tasks[&quot;${image}&quot;] = {
        node('docker') {
            stage(&quot;${image_inside}&quot;) {
                docker.image(&quot;${image_inside}&quot;).inside {
                    sh &quot;echo ${image_inside}&quot;
                    sh 'cat /etc/*-release'
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面這段程式要特別注意的是其中 &lt;strong&gt;def image_inside = “${image}”&lt;/strong&gt;，這是不能拿掉的喔！另外 &lt;strong&gt;docker.image&lt;/strong&gt; 這段是為了執行在 docker image 內，如果是一般的 agent 是不需要這段的。&lt;/p&gt;

&lt;p&gt;雖然這樣已經達到目的了，但是之後要增加 image 還要需要修改 Jenkinsfile，可能的話當然是希望將可能變動的部份抽離出來。&lt;/p&gt;

&lt;p&gt;要讓 Jenkinfile 不需要修改，可以透過外部檔案來設定 imagelist，所以我們要讀取檔案，並且設定到 imagelist 陣列中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def imagelist = readFile('imagelist').replace(&quot;\n&quot;, &quot;&quot;).split(',')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的指令，先是讀取 imagelist 檔案，移除換行符號之後，依照逗號分隔項目，最後存進 imagelist&lt;/p&gt;

&lt;p&gt;而 imagelist 檔案的內容則是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;maven:3-alpine,ubuntu:18.04,base/archlinux
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整的檔案在 &lt;a href=&quot;https://github.com/allyusd/jenkins-pipeline/tree/agent-docker-dynamic-parallel&quot;&gt;這裡&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;ref&quot;&gt;ref&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://devops.stackexchange.com/questions/3073/how-to-properly-achieve-dynamic-parallel-action-with-a-declarative-pipeline/3090#3090&quot;&gt;jenkins - How to properly achieve dynamic parallel action with a declarative pipeline? - DevOps Stack Exchange&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/42652533/limiting-jenkins-pipeline-to-running-only-on-specific-nodes?rq=1&quot;&gt;Limiting Jenkins pipeline to running only on specific nodes - Stack Overflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.jenkins-ci.org/browse/JENKINS-44086&quot;&gt;[JENKINS-44086] Parallel nodes for scripted pipelines cannot be clicked - Jenkins JIRA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/37594635/why-an-each-loop-in-a-jenkinsfile-stops-at-first-iteration&quot;&gt;jenkins - Why an each loop in a Jenkinsfile stops at first iteration - Stack Overflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/22917491/reading-file-from-workspace-in-jenkins-with-groovy-script&quot;&gt;Reading file from Workspace in Jenkins with Groovy script - Stack Overflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jenkins.io/doc/book/pipeline/docker/&quot;&gt;Using Docker with Pipeline&lt;/a&gt;&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">前一篇介紹平行工作，但是每個 stage 其實是一樣的東西，明明重覆的事情要寫好幾遍很討厭，能不能動態產生呢？</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - 平行工作</title><link href="https://twblog.hongjianching.com/2018/10/24/jenkins-pipeline-as-code-parallel/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - 平行工作" /><published>2018-10-24T00:00:00+08:00</published><updated>2018-10-24T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/24/jenkins-pipeline-as-code-parallel</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/24/jenkins-pipeline-as-code-parallel/">&lt;p&gt;在之前的範例中，我們都是使用連續流程 pipeline，當某一個 stage 失敗，則剩餘的 stage 直接跳過不再執行，以流水線來說這是正確的。&lt;/p&gt;

&lt;p&gt;一般流水線的基本 stage 是 build, test, deploy，當 build 失敗的時候，意味著下一個 test stage 勢必沒有辦法執行，所以直接跳過這個 stage。而 test 失敗的時候，表示沒有通過測試，不應該進行 deploy。&lt;/p&gt;

&lt;p&gt;但是，有個情況是，假如我是一個網頁程式，想要測試時跑在 chrome, firefox, ie 等環境，這時三者之間獨立存在，彼此沒有關聯。假如在 chrome 失敗了，並不代表在 firefox 及 ie 會失敗，所以不應該直接跳過，這時三個 stage 就應該是平行工作。&lt;/p&gt;

&lt;p&gt;接下來的測試借用前一篇&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/23/jenkins-pipeline-as-code-run-docker-image/&quot;&gt;Jenkins - Pipeline as Code - 啟動 Docker Image&lt;/a&gt;的範例來示範，原先執行了三個 docker image，我們現在故意讓第一個失敗，把 image 改為不存在的 &lt;strong&gt;non-exist:fail&lt;/strong&gt; 看看結果&lt;/p&gt;

&lt;p&gt;(已建立的檔案在 &lt;strong&gt;https://github.com/allyusd/jenkins-pipeline.git&lt;/strong&gt;，故意失敗的 branch 為 &lt;strong&gt;agent-docker-fail&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;從 Stage View 來看，只知道三個 stage 都是 failed 的結果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-41-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;實際到 Logs 確認後，可以發現第一個 stage 失敗之後，後續兩個 stage 直接跳過了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-39-29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;為了達到平行工作的目的，我們可以使用 &lt;strong&gt;parallel&lt;/strong&gt; 關鍵字，透過平行宣告，讓這三個 stage 不再有上下流的關係。&lt;/p&gt;

&lt;p&gt;原本的 Jenkinsfile 修改後如下&lt;/p&gt;

&lt;p&gt;(branch 為 &lt;strong&gt;agent-docker-parallel&lt;/strong&gt;)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pipeline {
    agent none
    stages {
        stage('parallel') {
            parallel {
                stage('alpine') {
                    agent {
                        docker {
                            label 'docker'
                            image 'maven:3-alpine'
                        }
                    }
                    steps {
                        sh 'cat /etc/*-release'
                    }
                }
                stage('ubuntu') {
                    agent {
                        docker {
                            label 'docker'
                            image 'ubuntu:18.04'
                        }
                    }
                    steps {
                        sh 'cat /etc/*-release'
                    }
                }
                stage('archlinux') {
                    agent {
                        docker {
                            label 'docker'
                            image 'base/archlinux'
                        }
                    }
                    steps {
                        sh 'cat /etc/*-release'
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;成功執行的情況跟原本的沒太大差別，只是多了一個 parallel stage，事實上沒有做什麼事情。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-47-42.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著把平行版本給弄壞，同樣讓第一個 stage 改成不存在的 image&lt;/p&gt;

&lt;p&gt;(branch 為 &lt;strong&gt;agent-docker-parallel-fail&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;執行後的 Stage View 明顯看出只有第一個 stage 是 failed，其它兩個 stage 都有順利執行，如果是在程式除錯的情況下，就會往第一個環境與其它不同的部份去 debug，為開發人員提供很好的判斷資訊&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-51-23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;改成平行工作，除了讓 stage 消除上下流關係，提供開發人員除錯資訊外，因為彼此獨立，所以如果在有多個可使用 agent 的情況下，是真的可以平行進行的喔。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-56-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上圖表示同樣是 #6，但是一個在執行的時候，還有兩個在佇列中等候，如果幫 Jenkins 再安裝兩個 agent，就可以看到同時進行喔！&lt;/p&gt;

&lt;p&gt;等等，突然想到目前的執行環境是使用 docker image，環境互不影響，那我只要將 ubuntu-18.04 agent &lt;strong&gt;執行程式數量&lt;/strong&gt; 設定為 3 就可以展示效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-24-jenkins-pipeline-as-code-parallel/2018-10-24_22-59-36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">在之前的範例中，我們都是使用連續流程 pipeline，當某一個 stage 失敗，則剩餘的 stage 直接跳過不再執行，以流水線來說這是正確的。</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - 啟動 Docker Image</title><link href="https://twblog.hongjianching.com/2018/10/23/jenkins-pipeline-as-code-run-docker-image/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - 啟動 Docker Image" /><published>2018-10-23T00:00:00+08:00</published><updated>2018-10-23T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/23/jenkins-pipeline-as-code-run-docker-image</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/23/jenkins-pipeline-as-code-run-docker-image/">&lt;p&gt;這篇要介紹透過 Jenkinsfile 直接啟動 Docker Image 來執行&lt;/p&gt;

&lt;p&gt;早前介紹過&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/10/install-jenkins-agent-with-docker/&quot;&gt;使用 Docker 安裝 Jenkins Agent&lt;/a&gt;，但是這個方法，每個環境都要建立一次該環境的 agent docker image，其實有點麻煩，難道不能讓我直接拿 docker image 來執行呢？&lt;/p&gt;

&lt;p&gt;答案是可以的，所以前一篇介紹&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/22/install-jenkins-agent-on-ubuntu/&quot;&gt;在 Ubuntu 安裝 Jenkins Agent&lt;/a&gt;，目的是使用該 ubuntu 上的 docker 執行環境。如果還沒有安裝 docker 的話，請參考這篇完成&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/02/install-docker/&quot;&gt;安裝 Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先將 ubuntu agent 加上 &lt;strong&gt;docker&lt;/strong&gt; 標籤，避免跑到其它沒有 docker 環境的 agent 上，那就會不能執行了喔&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-21-51.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著修改 Jenkinsfile 關於 agent 的宣告，原本是限制執行在有 &lt;strong&gt;cpp&lt;/strong&gt; 標籤上的像這樣&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;agent {
    label 'cpp'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;改為限制執行在 &lt;strong&gt;docker&lt;/strong&gt; 標籤上，而且要啟動 docker image &lt;strong&gt;maven:3-alpine&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;agent {
    docker {
        label 'docker'
        image 'maven:3-alpine'
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;為了展示在不同 docker image 上執行的能力，我們顯示執行環境的版本資訊&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;steps {
    sh 'cat /etc/*-release'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了 alpine 之外，我們額外新增 ubuntu 及 archlinux 來示範&lt;/p&gt;

&lt;p&gt;完整的 Jenkinsfile 如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pipeline {
    agent none
    stages {
        stage('alpine') {
            agent {
                docker {
                    label 'docker'
                    image 'maven:3-alpine'
                }
            }
            steps {
                sh 'cat /etc/*-release'
            }
        }
        stage('ubuntu') {
            agent {
                docker {
                    label 'docker'
                    image 'ubuntu:18.04'
                }
            }
            steps {
                sh 'cat /etc/*-release'
            }
        }
        stage('archlinux') {
            agent {
                docker {
                    label 'docker'
                    image 'base/archlinux'
                }
            }
            steps {
                sh 'cat /etc/*-release'
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要使用預建立的檔案，同樣在 &lt;strong&gt;https://github.com/allyusd/jenkins-pipeline.git&lt;/strong&gt;，branch 是 &lt;strong&gt;different-agent-docker&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;成功建置之後會出現三個 stage&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-31-20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;alpine 執行結果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-32-40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ubuntu 執行結果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-33-15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;archlinux 執行結果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-23-jenkins-pipeline-as-code-run-docker-image/2018-10-23_21-34-24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;透過 docker image 啟動不同環境是不是很有彈性呢？&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><category term="Docker" /><summary type="html">這篇要介紹透過 Jenkinsfile 直接啟動 Docker Image 來執行</summary></entry><entry><title type="html">在 Ubuntu 安裝 Jenkins Agent</title><link href="https://twblog.hongjianching.com/2018/10/22/install-jenkins-agent-on-ubuntu/" rel="alternate" type="text/html" title="在 Ubuntu 安裝 Jenkins Agent" /><published>2018-10-22T00:00:00+08:00</published><updated>2018-10-22T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/22/install-jenkins-agent-on-ubuntu</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/22/install-jenkins-agent-on-ubuntu/">&lt;p&gt;之前介紹過&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/10/install-jenkins-agent-with-docker/&quot;&gt;使用 Docker 安裝 Jenkins Agent&lt;/a&gt;，這次要講不使用 Docker 直接在 Ubuntu 安裝 Agent 的方法&lt;/p&gt;

&lt;p&gt;在 Jenkins 主頁，選擇&lt;strong&gt;管理 Jenkins&lt;/strong&gt; &amp;gt; &lt;strong&gt;管理節點&lt;/strong&gt; &amp;gt; &lt;strong&gt;新增節點&lt;/strong&gt; &amp;gt;
&lt;strong&gt;節點名稱&lt;/strong&gt;輸入 &lt;strong&gt;ubuntu-18.04&lt;/strong&gt;，按下 OK&lt;/p&gt;

&lt;p&gt;接著在設定頁輸入&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;遠端檔案系統根目錄：&lt;strong&gt;/data/jenkins&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;啟動模式：&lt;strong&gt;透過 SSH 啟動 Unitx 主機上的 agnet代理程式&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;主機：輸入 IP&lt;/li&gt;
  &lt;li&gt;Credentials：輸入登入主機的 SSH 帳號及密碼&lt;/li&gt;
  &lt;li&gt;Host Key Verification Strategy：圖方便跳過驗證，選擇&lt;strong&gt;Non verifying Verification Strategy&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-43-37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按下儲存之後可以看到 Agent 啟動 Logs，進去看一下發現失敗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-40-20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;訊息上看到提示安裝 java 8，我們透過 ssh 登入 Ubuntu 18.04，確認是不是沒有安裝 java&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-02-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;確實沒有安裝後，接著透過 apt 安裝 java 套件&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo apt install openjdk-8-jre -y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-36-56.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回到 Jenkins Web 再啟動一次，結果又有錯誤發生&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-52-49.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;檢查紀錄原來是 &lt;strong&gt;/data/jenkins&lt;/strong&gt; 目錄不存在，這個好處理。建立一下目鍵，別忘了設定權限&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mkdir -p /data/jenkins
sudo chown ubuntu:ubuntu /data -R
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;回到頁面再次啟動 Agent&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-22-install-jenkins-agent-on-ubuntu/2018-10-22_21-56-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;終於成功完成 Jenkins Agent 連線&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><category term="Ubuntu" /><summary type="html">之前介紹過使用 Docker 安裝 Jenkins Agent，這次要講不使用 Docker 直接在 Ubuntu 安裝 Agent 的方法</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - Slack Notifier</title><link href="https://twblog.hongjianching.com/2018/10/21/jenkins-pipeline-as-code-slack-notifier/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - Slack Notifier" /><published>2018-10-21T00:00:00+08:00</published><updated>2018-10-21T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/21/jenkins-pipeline-as-code-slack-notifier</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/21/jenkins-pipeline-as-code-slack-notifier/">&lt;p&gt;希望在 Pipeline 異常的時候通知你？透過 Slack Notifier 完成目的&lt;/p&gt;

&lt;h1 id=&quot;jenkins-slack-integration&quot;&gt;Jenkins Slack Integration&lt;/h1&gt;

&lt;p&gt;首先要到 slack 的 apps 管理頁面，&lt;code class=&quot;highlighter-rouge&quot;&gt;https://xxx.slack.com/apps/manage&lt;/code&gt;，其中 xxx 請代入自己的組織名稱，接著在上方搜尋的地方輸入 &lt;code class=&quot;highlighter-rouge&quot;&gt;jenkins&lt;/code&gt; 會出現 &lt;code class=&quot;highlighter-rouge&quot;&gt;Jenkins CI&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_21-46-24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;點選進入 Jenkins CI Apps 頁面，左方有個 &lt;code class=&quot;highlighter-rouge&quot;&gt;Install&lt;/code&gt; 按下去&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_21-46-46.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著會問你想要發訊息到哪一個 Channel，其實隨便選都可以，之後可以在 Jenkins 修改，這邊我選了 &lt;code class=&quot;highlighter-rouge&quot;&gt;#general&lt;/code&gt; 頻道&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_21-47-30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按下之後會有完整的圖文教學，首先要到 Jenkins 管理頁面安裝 &lt;strong&gt;Slack Notification Plugin&lt;/strong&gt;，我使用的 Jenkins 版本跟教學的圖片不一樣，會省略 Plugin 文字，所以要搜尋的話最好只用前面的 &lt;strong&gt;Slack Notification&lt;/strong&gt; 會比較好找到。&lt;/p&gt;

&lt;p&gt;安裝完外掛之後，要到&lt;strong&gt;管理 Jenkins&lt;/strong&gt;，&lt;strong&gt;設定系統&lt;/strong&gt;的&lt;strong&gt;Global Slack Notifier Settings&lt;/strong&gt; 貼上從 Jenkins CI App 教學頁面給的設定&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;設定 Base URL 為https://xxx.slack.com/services/hooks/jenkins-ci/&lt;/li&gt;
  &lt;li&gt;設定 Integration Token 為 Mursq71aDfDJke4cvUWx9n2f&lt;/li&gt;
  &lt;li&gt;設定 Channel 為 general&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;設定後可以按一下 &lt;strong&gt;Test Connection&lt;/strong&gt;，成功時 Slack 會出現測試訊息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_22-46-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jenkinsfile&quot;&gt;Jenkinsfile&lt;/h1&gt;

&lt;p&gt;因為訊息的發佈應該是跨越 stage 的，所以我們在 stages 平行新增一個 post 宣告。當 pipeline 失敗的時候，使用 &lt;strong&gt;failure&lt;/strong&gt; 宣告發送失敗的訊息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;color&lt;/strong&gt; 可以定義發佈訊息旁的顏色標示，失敗時用紅色
&lt;strong&gt;message&lt;/strong&gt; 就是發佈的訊息內容，為了提醒所有人注意到東西壞掉了，可以加上 @channel，太吵的話可以拿掉，或是討論一下為什麼常常壞掉。還可以透過 Jenkins 的變數提供有用的訊息，像是 &lt;strong&gt;env.JOB_BASE_NAME&lt;/strong&gt; 可以提供專案名稱，&lt;strong&gt;env.BUILD_URL&lt;/strong&gt; 則是提供本次建置的網址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;failure {
    slackSend color: '#FF0000',
    message: &quot;@channel ${env.JOB_BASE_NAME} failure. (${env.BUILD_URL})&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了壞掉的時候發出訊息通知外，我們也可以發送一些好消息，像是 &lt;strong&gt;fixed&lt;/strong&gt; 代表東西修好了，也就是原先建置失敗的專案，第一次建置成功的時候發出通知。這次的顏色用綠色，訊息則簡單的說明哪個專案回到建置成功的狀態&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fixed {
    slackSend color: '#00FF00',
    message: &quot;@channel ${env.JOB_BASE_NAME} back to success.&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因為完整的 Jenkinsfile 很長，這次不貼到文章上，直接給&lt;a href=&quot;https://github.com/allyusd/jenkins-pipeline/blob/slack-notifier/Jenkinsfile&quot;&gt;連結&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因為成功的建置不會發送訊息，所以我們先故意用一個壞掉的來建置&lt;/p&gt;

&lt;p&gt;同樣是 &lt;strong&gt;https://github.com/allyusd/jenkins-pipeline.git&lt;/strong&gt;，branch 是 &lt;strong&gt;slack-notifier-fail&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建置失敗，slack 收到了失敗通知&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_22-52-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著換成正確的 branch &lt;strong&gt;slack-notifier&lt;/strong&gt; 然後再建置一次&lt;/p&gt;

&lt;p&gt;這次建置成功，因為前一個建置失敗，所以 slack 收到修復通知&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-21-jenkins-pipeline-as-code-slack-notifier/2018-10-21_22-57-32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ref&quot;&gt;ref&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://jenkins.io/doc/pipeline/steps/slack/#slack-notification-plugin&quot;&gt;Slack Notification Plugin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jenkins.io/doc/pipeline/tour/post/&quot;&gt;Cleaning up and notifications&lt;/a&gt;&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">希望在 Pipeline 異常的時候通知你？透過 Slack Notifier 完成目的</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - Last Changes</title><link href="https://twblog.hongjianching.com/2018/10/20/jenkins-pipeline-as-code-last-changes/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - Last Changes" /><published>2018-10-20T00:00:00+08:00</published><updated>2018-10-20T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/20/jenkins-pipeline-as-code-last-changes</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/20/jenkins-pipeline-as-code-last-changes/">&lt;p&gt;這次要讓 Jenkins 可以顯示程式碼的變更&lt;/p&gt;

&lt;p&gt;這個功能要透過 plugin 來完成，所以要先安裝 plugin，在 Jenkins 首頁選擇&lt;code class=&quot;highlighter-rouge&quot;&gt;管理 Jenkins&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-20-jenkins-pipeline-as-code-last-changes/2018-10-20_22-33-28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在管理 Jenkins 頁面，選擇&lt;code class=&quot;highlighter-rouge&quot;&gt;管理外掛程式&lt;/code&gt;，這邊的外掛程式指的就是 Jenkins plugin&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-20-jenkins-pipeline-as-code-last-changes/2018-10-20_22-36-41.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在管理外掛程式頁面，會有四個分頁&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;更新
代表你已安裝的 plugin 有更新的版本可以安裝&lt;/li&gt;
  &lt;li&gt;可用的
代表你未安裝的 plugin&lt;/li&gt;
  &lt;li&gt;已安裝
代表你已安裝的 plugin&lt;/li&gt;
  &lt;li&gt;進階
關於 plugin 安裝的相關設定，HTTP Proxy設定、上傳外掛程式、更新網址等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在這裡我們選擇&lt;code class=&quot;highlighter-rouge&quot;&gt;可用的&lt;/code&gt;分頁&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-20-jenkins-pipeline-as-code-last-changes/2018-10-20_22-39-00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著在一大堆的 plugin 中找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Last Changes&lt;/code&gt;，可以透過 Ctrl + F 之類的機制會比較快找到喔&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-20-jenkins-pipeline-as-code-last-changes/2018-10-20_22-40-16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著選擇下方的&lt;code class=&quot;highlighter-rouge&quot;&gt;下載並於重新啟動後安裝&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-20-jenkins-pipeline-as-code-last-changes/2018-10-20_22-45-39.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正在安裝/升級 Plugins 頁面，把下方的&lt;code class=&quot;highlighter-rouge&quot;&gt;當安裝完成且沒有工作正在執行時，重啟 Jenkins&lt;/code&gt;打勾，這樣 Jenkins 就會自動重啟喔&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-20-jenkins-pipeline-as-code-last-changes/2018-10-20_22-49-20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Jenkins 重啟之後，plugin 就可以使用了，接下來修改 Jenkinsfile。關鍵字是 &lt;code class=&quot;highlighter-rouge&quot;&gt;lastChanges&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;format&lt;/code&gt; 選擇 &lt;code class=&quot;highlighter-rouge&quot;&gt;side-by-side&lt;/code&gt;，會將兩個版本分別顯示在左邊跟右邊，個人習慣這種方式。因為差異不論建置成功或失敗都會想看，所以我們放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;always&lt;/code&gt; 宣告內，有別於 archiveArtifacts 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;success&lt;/code&gt; 宣告只有在建置成功才執行，在 always 內的動作無論如何都會執行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;always {
    lastChanges format:'SIDE', matching: 'LINE'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;這次的程式碼同樣在 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://github.com/allyusd/jenkins-pipeline.git&lt;/code&gt;，branch 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;last-changes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;執行後，在左邊選單列會出現 &lt;code class=&quot;highlighter-rouge&quot;&gt;View Last Changes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-20-jenkins-pipeline-as-code-last-changes/2018-10-20_23-06-40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;View Last Changes 的結果如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-20-jenkins-pipeline-as-code-last-changes/2018-10-20_23-11-50.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;從上圖可以明顯的知道這次的程式碼修改了什麼，幫助判斷是什麼部份可以造成建置的錯誤&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">這次要讓 Jenkins 可以顯示程式碼的變更</summary></entry><entry><title type="html">Jenkins - Pipeline as Code - 測試報告</title><link href="https://twblog.hongjianching.com/2018/10/19/jenkins-pipeline-as-code-test-report/" rel="alternate" type="text/html" title="Jenkins - Pipeline as Code - 測試報告" /><published>2018-10-19T00:00:00+08:00</published><updated>2018-10-19T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/19/jenkins-pipeline-as-code-test-report</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/19/jenkins-pipeline-as-code-test-report/">&lt;p&gt;這篇的主題是測試報告，接續 &lt;a href=&quot;https://twblog.hongjianching.com/2018/10/17/jenkins-pipeline-as-code-artifacts/&quot;&gt;Jenkins - Pipeline as Code - 封存檔案&lt;/a&gt;及&lt;a href=&quot;https://twblog.hongjianching.com/2018/10/18/google-test-on-ubuntu/&quot;&gt;在 Ubuntu 使用 Google Test&lt;/a&gt;兩篇文章，這篇要整合起來&lt;/p&gt;

&lt;h1 id=&quot;build&quot;&gt;Build&lt;/h1&gt;
&lt;p&gt;首先，原本的 C++ 專案，新增 Google Test 在 git branch &lt;code class=&quot;highlighter-rouge&quot;&gt;gtest&lt;/code&gt;，所以要修改原本 Jenkinsfile 指定 branch&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git branch: 'gtest', url: 'https://github.com/allyusd/helloworld.cpp.git'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;同時新增建置 unit test 的部份&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sh 'g++ unittest.cpp -o unittest -Igtest/include -Lgtest/lib -lgtest -lpthread'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;別忘了也要封裝 unittest 檔案，才能在另一個 agent 中執行&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;archiveArtifacts artifacts: 'helloworld,unittest'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;test&quot;&gt;Test&lt;/h1&gt;
&lt;p&gt;接著修改 Test 階段，將原本執行 helloworld 換成 unittest，並且加上參數  –gtest_output=”xml:report.xml” 產生測試報告&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./unittest --gtest_output=&quot;xml:report.xml&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;接著就要將測試報告上傳到 Jenkins，才能在 Web UI 出現結果&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;post {
    always {
        junit '*.xml'
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;結果&quot;&gt;結果&lt;/h1&gt;
&lt;p&gt;完整修改後的內容如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pipeline {
    agent none
    stages {
        stage('Build') {
            agent {
                label 'cpp'
            }
            steps {
                echo 'Building..'
                git branch: 'gtest', url: 'https://github.com/allyusd/helloworld.cpp.git'
                sh 'g++ helloworld.cpp -o helloworld'
                sh 'g++ unittest.cpp -o unittest -Igtest/include -Lgtest/lib -lgtest -lpthread'
            }
            post {
                success {
                    archiveArtifacts artifacts: 'helloworld,unittest'
                }
            }
        }
        stage('Test') {
            agent {
                label 'test'
            }
            steps {
                echo 'Testing..'
                sh '''#!/bin/bash
                curl -O ${BUILD_URL}artifact/unittest
                chmod +x unittest
                ./unittest --gtest_output=&quot;xml:report.xml&quot;
                '''
            }
            post {
                always {
                    junit '*.xml'
                }
            }
        }
        stage('Deploy') {
            steps {
                echo 'Deploying....'
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果要使用已建立好的檔案，同樣在 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://github.com/allyusd/jenkins-pipeline.git&lt;/code&gt;，這次是 &lt;code class=&quot;highlighter-rouge&quot;&gt;test-report&lt;/code&gt; branch&lt;/p&gt;

&lt;p&gt;執行後，在專案主頁會出現&lt;code class=&quot;highlighter-rouge&quot;&gt;測試結果趨勢&lt;/code&gt;圖&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-19-jenkins-pipeline-as-code-test-report/2018-10-19_22-17-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;並且在建置頁面會出現&lt;code class=&quot;highlighter-rouge&quot;&gt;測試結果&lt;/code&gt;，如果有失敗的測試，這邊可以查閱
&lt;img src=&quot;/assets/images/2018-10-19-jenkins-pipeline-as-code-test-report/2018-10-19_22-18-53.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Jenkins" /><summary type="html">這篇的主題是測試報告，接續 Jenkins - Pipeline as Code - 封存檔案及在 Ubuntu 使用 Google Test兩篇文章，這篇要整合起來</summary></entry><entry><title type="html">在 Ubuntu 使用 Google Test</title><link href="https://twblog.hongjianching.com/2018/10/18/google-test-on-ubuntu/" rel="alternate" type="text/html" title="在 Ubuntu 使用 Google Test" /><published>2018-10-18T00:00:00+08:00</published><updated>2018-10-18T00:00:00+08:00</updated><id>https://twblog.hongjianching.com/2018/10/18/google-test-on-ubuntu</id><content type="html" xml:base="https://twblog.hongjianching.com/2018/10/18/google-test-on-ubuntu/">&lt;p&gt;要使用 Google Test，首先要取得程式碼&lt;/p&gt;

&lt;p&gt;原始碼可以在 &lt;a href=&quot;https://github.com/google/googletest/releases&quot;&gt;Releases · google/googletest&lt;/a&gt; 下載，在 Ubuntu 則可以透過 libgtest-dev 套件取得&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt install libgtest-dev -y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;套件會安裝在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/src/gtest&lt;/code&gt; 目錄下&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /usr/src/gtest
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;透過 cmake 進行建置設定，產生 makefile&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake CMakeLists.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最後進行建置&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;成功建置後會產生 libgtest.a 及 libgtest_main.a 兩個檔案&lt;/p&gt;

&lt;p&gt;接著建立一個檔案測試一下&lt;/p&gt;

&lt;p&gt;unittest.cpp&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;gtest/gtest.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define HELLOWORLD &quot;Hello World&quot;
&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GoogleTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HelloWorld&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HELLOWORLD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InitGoogleTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUN_ALL_TESTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一行引用 gtest 的 header，接著定義 HELLOWORLD 代表實際結果&lt;/p&gt;

&lt;p&gt;Test 代表一個測試案例，HelloWorld 代表此測試案例的名稱，GoogleTest 則為多個測試案例的群組名稱，常見用法是以測試對象的 class 名稱命名。測試案例的內容可以用 ASSERT_EQ 來判斷期望值與實際值是否相等&lt;/p&gt;

&lt;p&gt;最後一段是初始化 Google Test 及執行所有的測試案例。&lt;/p&gt;

&lt;p&gt;寫好測試檔案，就可以進行測試程式的建置&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g++ unittest.cpp -o unittest -Igtest/include -Lgtest/lib -lgtest -lpthread
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;建置成功後，執行測試程式&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./unittest
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;測試結果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-10-18-google-test-on-ubuntu/2018-10-18_22-46-15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>洪健清</name><email>allyusd yahoo com tw</email><uri>https://www.HongJianChing.com/</uri></author><category term="2019-iT-邦幫忙鐵人賽" /><category term="Google-Test" /><category term="Ubuntu" /><summary type="html">要使用 Google Test，首先要取得程式碼</summary></entry></feed>